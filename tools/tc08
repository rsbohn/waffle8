#!/usr/bin/env python3
"""
TC08 magtape utility: read blocks from a .tu56 tape image.

Usage:
    tc08 read <tape-image> <block>

Prints the contents of the specified block in 8-word groups:
<offset>: <word0> <word1> ... <word7>

The tape format:
- twelve-bit words in 16-bit
- 256 words per block
- DIRECTORY is in block 1

"""
import sys
import struct
import os

def sixbit_char(val):
    c = val & 0x3F
    if c == 0:
        return ' '
    elif 1 <= c <= 26:
        return chr(ord('A') + c - 1)
    elif 27 <= c <= 36:
        return chr(ord('0') + c - 27)
    elif c == 46:
        return '.'
    else:
        return '_'

def print_sixbit_pairs(words):
    for i in range(0, len(words), 8):
        chunk = words[i:i+8]
        chars = []
        for w in chunk:
            hi = sixbit_char((w >> 6) & 0x3F)
            lo = sixbit_char(w & 0x3F)
            chars.append(f"{hi}{lo}")
        chunk_str = ' '.join(chars)
        print(f"{i:04o}: {chunk_str}")

def unpack_24bit_block(data):
    # Each block is 129 12-bit words, packed as 24-bit little-endian sequences (3 bytes = 2 words)
    if len(data) != 194:  # 129 words * 12 bits = 1548 bits = 194 bytes (rounded up)
        # Actually, 129*12 = 1548 bits = 193.5 bytes, so 194 bytes
        raise ValueError("Block must be exactly 194 bytes (129*12 bits packed)")
    words = []
    i = 0
    while len(words) < 129:
        if i+2 >= len(data):
            break
        b0 = data[i]
        b1 = data[i+1]
        b2 = data[i+2]
        w1 = ((b1 & 0x0F) << 8) | b0
        w2 = (b2 << 4) | ((b1 & 0xF0) >> 4)
        words.append(w1 & 0xFFF)
        if len(words) < 129:
            words.append(w2 & 0xFFF)
        i += 3
    return words

def unpack_16bit_words(data):
    words = []
    for i in range(0, len(data), 2):
        w = struct.unpack('<H', data[i:i+2])[0] & 0o7777
        words.append(w)
    return words

def read_block(image_path, block_num, sixbit_mode=False):
    BLOCK_SIZE_WORDS = 256
    PACKED_BLOCK_SIZE = 512  # 256 words * 2 bytes
    block_num = int(block_num)
    offset = block_num * PACKED_BLOCK_SIZE
    with open(image_path, 'rb') as f:
        f.seek(offset)
        data = f.read(PACKED_BLOCK_SIZE)
        if len(data) < PACKED_BLOCK_SIZE:
            print(f"Block {block_num} is incomplete or past end of file.", file=sys.stderr)
            sys.exit(1)
        words = unpack_16bit_words(data)
        if sixbit_mode:
            print_sixbit_pairs(words)
        else:
            for i in range(0, BLOCK_SIZE_WORDS, 8):
                chunk = words[i:i+8]
                chunk_str = ' '.join(f"{w:04o}" for w in chunk)
                print(f"{i:04o}: {chunk_str}")
    


# Move print_os8_directory above main()
def print_os8_directory(image_path, dir_block=1):
    BLOCK_SIZE_WORDS = 256
    PACKED_BLOCK_SIZE = 512
    offset = dir_block * PACKED_BLOCK_SIZE
    with open(image_path, 'rb') as f:
        f.seek(offset)
        data = f.read(PACKED_BLOCK_SIZE)
        if len(data) < PACKED_BLOCK_SIZE:
            print(f"Directory block {dir_block} is incomplete or past end of file.", file=sys.stderr)
            sys.exit(1)
        words = unpack_16bit_words(data)
        print("OS/8 Directory (block %d):" % dir_block)
        print("  FILE      EXT  START  LENGTH FLAGS")
        for i in range(0, BLOCK_SIZE_WORDS, 6):
            entry = words[i:i+6]
            if all(w == 0 for w in entry):
                continue
            # OS/8 directory entry format:
            # Words 0 and 1: 9 filename chars (6 bits each), then 3 extension chars (6 bits each)
            # Pack words 0 and 1 into a 36+18=54 bit bitstream
            bitstream = (entry[0] << 16) | entry[1]

            # Extract 9 filename chars (bits 53-0)
            filename = ''
            for n in range(9):
                shift = 54 - 6 * (n + 1)
                filename += sixbit_char((bitstream >> shift) & 0x3F)
            # Extract 3 extension chars (bits 17-0)
            ext = ''
            for n in range(3):
                shift = 18 - 6 * (n + 1)
                ext += sixbit_char((bitstream >> shift) & 0x3F)
            start = entry[2] & 0x0FFF
            length = entry[3] & 0x0FFF
            flags = entry[5]
            filename = filename.rstrip()
            ext = ext.rstrip()
            if filename.strip() == '' and ext.strip() == '':
                continue
            print(f"  {filename:<9} {ext:<3} {start:5o}  {length:6o}  {flags:04o}")

def main():
    import argparse
    parser = argparse.ArgumentParser(description="TC08 magtape utility")
    subparsers = parser.add_subparsers(dest="command")
    read_parser = subparsers.add_parser("read", help="Read and print a block")
    read_parser.add_argument("image", help="Tape image file")
    read_parser.add_argument("block", type=int, help="Block number")
    read_parser.add_argument("-s", "--sixbit", action="store_true", help="Print each word as two sixbit chars")
    dir_parser = subparsers.add_parser("dir", help="Print OS/8 directory entries")
    dir_parser.add_argument("image", help="Tape image file")
    args = parser.parse_args()

    if args.command == "read":
        if not os.path.isfile(args.image):
            print(f"File not found: {args.image}", file=sys.stderr)
            sys.exit(1)
        read_block(args.image, args.block, sixbit_mode=args.sixbit)
    elif args.command == "dir":
        if not os.path.isfile(args.image):
            print(f"File not found: {args.image}", file=sys.stderr)
            sys.exit(1)
        print_os8_directory(args.image)
    else:
        parser.print_help()
        sys.exit(2)

if __name__ == "__main__":
    main()
