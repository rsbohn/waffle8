#!/usr/bin/env python3
"""
DECtape utility for OS/8 images (.tu56, SIMH format).

Features:
- read: dump a DECtape block (physical 129-word frames by default; OS/8 logical
        256-word blocks with --logical).
- dir:  parse an OS/8 directory segment (block 1 by default) using the layout
        described in pip.pa (4-word header, variable-width entries, DLINK follow).
"""

import argparse
import os
import struct
import sys
from typing import Iterable, List, Tuple

BLOCK_WORDS = 129              # physical DECtape block size in 12-bit words
BLOCK_BYTES = BLOCK_WORDS * 2  # packed little-endian 16-bit words on disk
# OS/8 logical blocks are 256 words assembled from two physical frames (258*2 = 516 bytes).
OS8_LOGICAL_WORDS = 256
OS8_LOGICAL_BYTES = OS8_LOGICAL_WORDS * 2
OS8_LOGICAL_STRIDE = 512  # OS/8 logical block size in bytes


def _unpack_words(data: bytes) -> List[int]:
    return [struct.unpack("<H", data[i:i + 2])[0] & 0o7777 for i in range(0, len(data), 2)]


def sixbit_char(val: int) -> str:
    c = val & 0x3F
    if c == 0:
        return " "
    if 1 <= c <= 26:
        return chr(ord("A") + c - 1)
    if 27 <= c <= 36:
        return chr(ord("0") + c - 27)
    if c == 46:
        return "."
    return "_"


def sixbit_pair(word: int) -> str:
    return sixbit_char((word >> 6) & 0x3F) + sixbit_char(word & 0x3F)


def signed12(word: int) -> int:
    """Interpret a 12-bit word as a signed integer."""
    return word if word < 0o4000 else word - 0o10000


def read_physical_block(path: str, block: int) -> List[int]:
    offset = block * BLOCK_BYTES
    with open(path, "rb") as f:
        f.seek(offset)
        data = f.read(BLOCK_BYTES)
    if len(data) != BLOCK_BYTES:
        raise ValueError(f"Block {block} is incomplete (got {len(data)} bytes).")
    return _unpack_words(data)


def read_os8_block(path: str, block: int) -> List[int]:
    """Read an OS/8 logical block (256 data words).

    OS/8 lays a 256-word logical block across two physical DECtape frames:
    take physical blocks 2*block and 2*block+1, drop the trailing checksum
    word from each (129 -> 128 words), and concatenate.
    """
    phys0 = 2 * block
    phys1 = phys0 + 1
    size = os.path.getsize(path)
    total_phys = size // BLOCK_BYTES
    if phys1 >= total_phys:
        raise ValueError(f"Block {block} is incomplete (physical blocks {phys0},{phys1} not present).")
    w0 = read_physical_block(path, phys0)
    w1 = read_physical_block(path, phys1)
    data_words = w0[:-1] + w1[:-1]
    if len(data_words) != OS8_LOGICAL_WORDS:
        raise ValueError(f"Block {block} combined length {len(data_words)} != {OS8_LOGICAL_WORDS}.")
    return data_words


def dump_block(words: Iterable[int], sixbit: bool) -> None:
    words = list(words)
    if sixbit:
        for i in range(0, len(words), 8):
            chunk = words[i:i + 8]
            rendered = " ".join(f"{sixbit_pair(w)}" for w in chunk)
            print(f"{i:04o}: {rendered}")
    else:
        for i in range(0, len(words), 8):
            chunk = words[i:i + 8]
            rendered = " ".join(f"{w:04o}" for w in chunk)
            print(f"{i:04o}: {rendered}")


def parse_directory_segment(words: List[int]) -> Tuple[dict, List[dict]]:
    """Parse an OS/8 directory segment taken from a DECtape logical block.

    DECtape frames include a 5-word leader before the directory payload.
    The usable directory begins at words[5:] and uses 6-word entries with
    length stored as two's-complement negative.
    """
    if len(words) < 11:
        raise ValueError("Directory segment too small.")
    leader = words[:5]
    count = abs(signed12(leader[0]))
    origin, link = leader[1], leader[2]
    header = {
        "raw": leader,
        "count": count,
        "origin": origin,
        "link": link,
    }
    entries: List[dict] = []
    idx = 5
    current_block = origin
    entry_idx = 0
    free_blocks = 0
    while entry_idx < count and idx + 5 < len(words):
        name1, name2, name3, name4, date, length_word = words[idx:idx + 6]
        length_signed = signed12(length_word)
        length_blocks = abs(length_signed)
        filename = (
            sixbit_pair(name1)
            + sixbit_pair(name2)
            + sixbit_pair(name3)
        ).rstrip()
        ext = sixbit_pair(name4).rstrip()
        if name1 == 0:
            status = "free"
        elif length_word == 0:
            status = "tentative"
        else:
            status = "file"
        entries.append(
            {
                "index": entry_idx,
                "start_block": current_block,
                "length_blocks": length_blocks,
                "status": status,
                "name": filename,
                "ext": ext,
                "date_raw": date,
                "length_word": length_word,
            }
        )
        current_block += length_blocks
        if status == "free":
            free_blocks += length_blocks
        entry_idx += 1
        idx += 6
        if name1 == 0 and length_word == 0:
            break
    header["free_blocks"] = free_blocks
    return header, entries


def print_directory(path: str, start_block: int = 1) -> None:
    seen = set()
    block = start_block
    while block and block not in seen:
        seen.add(block)
        words = read_os8_block(path, block)
        header, entries = parse_directory_segment(words)
        leader = " ".join(f"{w:04o}" for w in header["raw"])
        print(f"Directory block {block} (leader={leader}, count={header['count']:04o}, "
              f"origin={header['origin']:04o}, link={header['link']:04o}, "
              f"free_blocks={header.get('free_blocks', 0):04o})")
        for e in entries:
            label = f"{e['name']}.{e['ext']}" if e["ext"] else e["name"]
            if e["status"] == "free":
                print(f"  [{e['index']:02d}] <FREE>  blocks={e['length_blocks']}")
            elif e["status"] == "tentative":
                print(f"  [{e['index']:02d}] <TENTATIVE> start={e['start_block']:04o} len=0")
            else:
                print(
                    f"  [{e['index']:02d}] {label:<8} start={e['start_block']:04o} "
                    f"len={e['length_blocks']:04o} date(oct)={e['date_raw']:04o}"
                )
        block = header["link"]
        if block == 0:
            break
    if block in seen:
        print(f"Stopped on repeated link to block {block} (possible loop).", file=sys.stderr)


def main() -> None:
    parser = argparse.ArgumentParser(description="DECtape utility for OS/8 images.")
    sub = parser.add_subparsers(dest="cmd")

    p_read = sub.add_parser("read", help="Dump a DECtape block.")
    p_read.add_argument("image")
    p_read.add_argument("block", type=int)
    p_read.add_argument(
        "--logical",
        action="store_true",
        help="Interpret block number as OS/8 logical block (256 words over two frames).",
    )
    p_read.add_argument("-s", "--sixbit", action="store_true", help="Show sixbit pairs instead of octal words.")

    p_dir = sub.add_parser("dir", help="Parse and print an OS/8 directory (block 1 by default).")
    p_dir.add_argument("image")
    p_dir.add_argument("-b", "--block", type=int, default=1, help="Directory block number (default 1).")

    args = parser.parse_args()
    if args.cmd == "read":
        if not os.path.isfile(args.image):
            sys.exit(f"File not found: {args.image}")
        reader = read_os8_block if args.logical else read_physical_block
        words = reader(args.image, args.block)
        dump_block(words, sixbit=args.sixbit)
    elif args.cmd == "dir":
        if not os.path.isfile(args.image):
            sys.exit(f"File not found: {args.image}")
        print_directory(args.image, start_block=args.block)
    else:
        parser.print_help()
        sys.exit(2)


if __name__ == "__main__":
    main()
