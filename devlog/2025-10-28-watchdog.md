# 2025-10-28 Implement a Watchdog Timer

Objectives:
- Provide a timer facility that can force a CPU reset or halt after a wall-clock timeout.
- Expose the device via IOT so guest code can control and query it.

Summary of final design and implementation (recorded):

Peripheral description
- The watchdog is a configurable countdown timer expressed in deciseconds (tenths of a second).
- The control register is a 12-bit word with a 3-bit command in bits 11..9 and a 9-bit count in bits 8..0 (count in deciseconds).

Control register encoding (bits 11..0):
- CMD (bits 11..9):
	- 000 = disabled
	- 001 = RESET (one-shot)
	- 010 = RESET (periodic)
	- 011 = HALT (one-shot)
	- 100 = HALT (periodic)
	- other encodings reserved
- COUNT (bits 8..0): initial countdown in deciseconds (0..511). 0 means disabled / no countdown.

IOT interface (device code assigned in codebase)
- IOT microbits interpretation:
	- 01 (WRITE): write AC into the control register (start/stop per CMD)
	- 02 (READ):  read the control register into AC
	- 04 (RESTART): reload the counter from the COUNT field and resume ticking

Runtime behavior and implementation notes
- The core adds a tick-callback API that devices may register. The watchdog registers a tick handler called on each CPU step with a monotonic timestamp.
- The countdown uses monotonic wall-clock time and is checked on each step; the implementation converts COUNT (deciseconds) into nanoseconds and compares against the last armed timestamp.
- When the watchdog fires:
	- RESET semantics: the core PC is set to 0 (simulating a reset vector jump).
	- HALT semantics: the core HALT state is set via the API.
	- INTERRUPT semantics were discussed but are not implemented yet; they currently map to RESET as a safe fallback.
- One-shot vs periodic: one-shot clears/disable after firing; periodic reloads and continues ticking.

Configuration and wiring
- `pdp8.config` now contains a `device watchdog { ... }` stanza. The monitor reads these fields at startup and, if enabled, creates and attaches the watchdog device.
- Config keys recognized: `iot` (documentation only), `enabled`, `mode` (string), `periodic` (bool), `default_count` (int), `pause_on_halt` (bool).

Tests and validation
- A Python factory test `factory/test_watchdog.py` exercises READ/WRITE, one-shot HALT, and one-shot RESET against the shared `libpdp8.so` — tests pass locally.
- A C test `tests/test_config.c` verifies parsing of the `pdp8.config` watchdog stanza and was extended to run invalid-config scenarios (missing stanza and out-of-bounds values). These tests pass locally.

Open/remaining items
- Device interrupts: true device interrupt delivery (DEVICE-LEVEL IRQ) is not yet implemented. Currently interrupt-mode falls back to RESET. Follow-up: wire into the core's interrupt/priority system if desired.
- Pause semantics: `pause_on_halt` is parsed and available; current implementation uses monotonic time and relies on the tick handler to avoid advancing the counter during emulator pause in practice — but more precise paused-time accounting can be implemented if required.
- More config validation: parser currently tolerates/records many invalid values; we added tests for those scenarios. Consider stricter validation and clearer errors in future.

Developer notes
- POSIX feature macros were required in a couple of files to make `clock_gettime()`/`mkdtemp()` and friends available.
- When adding the watchdog source, the relevant build targets in the `Makefile` were updated so the monitor and shared library include the new file.

Status
- Implementation: complete and merged into the workspace.
- Tests: local factory and config tests pass.

Next steps
- If you want interrupt-mode semantics implemented instead of RESET, I can wire the watchdog into the core interrupt handling and add tests.
- If you want stricter config validation, I can implement that and update tests accordingly.
- If you want stricter config validation, I can implement that and update tests accordingly.

Factory driver wiring (2025-10-28)
- The Python `factory/driver.py` runner did not originally attach the watchdog. I added optional wiring so the factory can create and initialize the watchdog when a `device watchdog { ... }` stanza is present in `pdp8.config`.
- What was changed in the factory driver:
	- `DeviceConfig` now contains watchdog fields (`watchdog_present`, `watchdog_enabled`, `watchdog_mode`, `watchdog_periodic`, `watchdog_default_count`, `watchdog_pause_on_halt`).
	- The `load_device_config()` parser recognizes a `device watchdog { ... }` block and populates the fields above.
	- The driver defines the watchdog IOT constants and an `execute_iot()` helper that writes an IOT instruction into address 0 and steps the CPU once. This allows the driver to initialize the watchdog control register via the existing IOT interface rather than requiring a new C API function.
	- At startup, if `watchdog_present && watchdog_enabled` and the shared library exports `pdp8_watchdog_create`, the driver will create and attach the watchdog device. If `default_count` is set, the driver composes a control word (CMD inferred from `mode`) and issues a WRITE IOT to initialize the device.
	- The driver destroys the watchdog in the `finally` cleanup when present.

Behavior and safety:
- The driver checks for the presence of the `pdp8_watchdog_*` symbols (via `hasattr(lib, ...)`) and falls back gracefully if the shared library is older and lacks the device.
- The driver uses a heuristic to map `mode` to CMD: if the `mode` string contains the substring "halt" it chooses HALT, otherwise RESET. This is intentionally conservative; we can tighten it to accept only explicit tokens.

Validation run:
- I ran the driver non-interactively against `demo/hello-wd.srec` after wiring the driver. Output included the normal factory messages and completed with the demo halting as expected. This verifies the wiring and initialization path end-to-end in the factory runner.

Follow-ups:
- If you prefer a cleaner factory->watchdog API, I can add a small C helper (for example `pdp8_watchdog_write_control(cpu, value)`) and call that from the driver instead of issuing an IOT.
- I can also make `mode` parsing strict (accept only `reset`, `halt`, `interrupt`) and surface warnings or errors on invalid values.

