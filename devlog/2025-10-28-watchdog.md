# 2025-10-28 Implement a Watchdog Timer

Objectives:
- Provide a timer facility that can force a CPU reset or halt after a wall-clock timeout.
- Expose the device via IOT so guest code can control and query it.

Summary of final design and implementation (recorded):

Peripheral description
- The watchdog is a configurable countdown timer expressed in deciseconds (tenths of a second).
- The control register is a 12-bit word with a 3-bit command in bits 11..9 and a 9-bit count in bits 8..0 (count in deciseconds).

Control register encoding (bits 11..0):
- CMD (bits 11..9):
	- 000 = disabled
	- 001 = RESET (one-shot)
	- 010 = RESET (periodic)
	- 011 = HALT (one-shot)
	- 100 = HALT (periodic)
	- other encodings reserved
- COUNT (bits 8..0): initial countdown in deciseconds (0..511). 0 means disabled / no countdown.

IOT interface (device code assigned in codebase)
- IOT microbits interpretation:
	- 01 (WRITE): write AC into the control register (start/stop per CMD)
	- 02 (READ):  read the control register into AC
	- 04 (RESTART): reload the counter from the COUNT field and resume ticking

Runtime behavior and implementation notes
- The core adds a tick-callback API that devices may register. The watchdog registers a tick handler called on each CPU step with a monotonic timestamp.
- The countdown uses monotonic wall-clock time and is checked on each step; the implementation converts COUNT (deciseconds) into nanoseconds and compares against the last armed timestamp.
- When the watchdog fires:
	- RESET semantics: the core PC is set to 0 (simulating a reset vector jump).
	- HALT semantics: the core HALT state is set via the API.
	- INTERRUPT semantics were discussed but are not implemented yet; they currently map to RESET as a safe fallback.
- One-shot vs periodic: one-shot clears/disable after firing; periodic reloads and continues ticking.

Configuration and wiring
- `pdp8.config` now contains a `device watchdog { ... }` stanza. The monitor reads these fields at startup and, if enabled, creates and attaches the watchdog device.
- Config keys recognized: `iot` (documentation only), `enabled`, `mode` (string), `periodic` (bool), `default_count` (int), `pause_on_halt` (bool).

Tests and validation
- A Python factory test `factory/test_watchdog.py` exercises READ/WRITE, one-shot HALT, and one-shot RESET against the shared `libpdp8.so` — tests pass locally.
- A C test `tests/test_config.c` verifies parsing of the `pdp8.config` watchdog stanza and was extended to run invalid-config scenarios (missing stanza and out-of-bounds values). These tests pass locally.

Open/remaining items
- Device interrupts: true device interrupt delivery (DEVICE-LEVEL IRQ) is not yet implemented. Currently interrupt-mode falls back to RESET. Follow-up: wire into the core's interrupt/priority system if desired.
- Pause semantics: `pause_on_halt` is parsed and available; current implementation uses monotonic time and relies on the tick handler to avoid advancing the counter during emulator pause in practice — but more precise paused-time accounting can be implemented if required.
- More config validation: parser currently tolerates/records many invalid values; we added tests for those scenarios. Consider stricter validation and clearer errors in future.

Developer notes
- POSIX feature macros were required in a couple of files to make `clock_gettime()`/`mkdtemp()` and friends available.
- When adding the watchdog source, the relevant build targets in the `Makefile` were updated so the monitor and shared library include the new file.

Status
- Implementation: complete and merged into the workspace.
- Tests: local factory and config tests pass.

Next steps
- If you want interrupt-mode semantics implemented instead of RESET, I can wire the watchdog into the core interrupt handling and add tests.
- If you want stricter config validation, I can implement that and update tests accordingly.
- If you want stricter config validation, I can implement that and update tests accordingly.

Factory driver wiring (2025-10-28)
- The Python `factory/driver.py` runner did not originally attach the watchdog. I added optional wiring so the factory can create and initialize the watchdog when a `device watchdog { ... }` stanza is present in `pdp8.config`.
- What was changed in the factory driver:
	- `DeviceConfig` now contains watchdog fields (`watchdog_present`, `watchdog_enabled`, `watchdog_mode`, `watchdog_periodic`, `watchdog_default_count`, `watchdog_pause_on_halt`).
	- The `load_device_config()` parser recognizes a `device watchdog { ... }` block and populates the fields above.
	- The driver defines the watchdog IOT constants and an `execute_iot()` helper that writes an IOT instruction into address 0 and steps the CPU once. This allows the driver to initialize the watchdog control register via the existing IOT interface rather than requiring a new C API function.
	- At startup, if `watchdog_present && watchdog_enabled` and the shared library exports `pdp8_watchdog_create`, the driver will create and attach the watchdog device. If `default_count` is set, the driver composes a control word (CMD inferred from `mode`) and issues a WRITE IOT to initialize the device.
	- The driver destroys the watchdog in the `finally` cleanup when present.

Behavior and safety:
- The driver checks for the presence of the `pdp8_watchdog_*` symbols (via `hasattr(lib, ...)`) and falls back gracefully if the shared library is older and lacks the device.
- The driver uses a heuristic to map `mode` to CMD: if the `mode` string contains the substring "halt" it chooses HALT, otherwise RESET. This is intentionally conservative; we can tighten it to accept only explicit tokens.

Validation run:
- I ran the driver non-interactively against `demo/hello-wd.srec` after wiring the driver. Output included the normal factory messages and completed with the demo halting as expected. This verifies the wiring and initialization path end-to-end in the factory runner.

Follow-ups:
- If you prefer a cleaner factory->watchdog API, I can add a small C helper (for example `pdp8_watchdog_write_control(cpu, value)`) and call that from the driver instead of issuing an IOT.
- I can also make `mode` parsing strict (accept only `reset`, `halt`, `interrupt`) and surface warnings or errors on invalid values.



Monitor & monitor-docs follow-up (2025-10-28, afternoon)
---------------------------------------------------

Today I made a few small follow-on changes to improve observability and documentation of the watchdog device:

- Monitor: `show devices` now includes a Watchdog section derived from `pdp8.config` so users can see configured watchdog fields alongside other peripherals (IOT, enabled, mode, periodic, default count, pause_on_halt).
- Monitor: added a runtime-aware `show watchdog` command that inspects the attached watchdog instance and prints live state including:
  - enabled (yes/no)
  - cmd (human-readable plus raw value)
  - configured count (deciseconds)
  - time remaining (deciseconds) or `(not running)` if not active
  - expired (yes/no)
  This lets you observe the live countdown without guessing from wall-clock delays.
- Code changes (high-level):
  - `tools/monitor.c`: added `show_watchdog()` and wired it into `command_show` as `show watchdog` and also extended `show devices` to display the configured watchdog stanza.
  - `src/emulator/watchdog.h`: added `struct pdp8_watchdog_status` and a prototype for `pdp8_watchdog_get_status()` so external code (the monitor) can query live state safely.
  - `src/emulator/watchdog.c`: implemented `pdp8_watchdog_get_status()` which reports enabled/expired/cmd/configured_count and converts the internal expiry timestamp to a decisecond remaining value.
  - `docs/watchdog.md`: appended "Disabling the watchdog from the monitor" with the sequence `CLA` / `IOT 6551` / `HLT` and explanatory notes.

Verification performed:
- Rebuilt the monitor to ensure the new symbols and monitor changes compile and link.
- Ran the monitor and validated:
  - `show devices` prints the watchdog config block when `pdp8.config` contains the watchdog stanza.
  - `show watchdog` reports `(device not attached)` when the watchdog wasn't created/attached by the monitor, and prints live fields when the monitor created and attached the watchdog at startup (i.e. when `watchdog_present && watchdog_enabled` in `pdp8.config`).
  - Demonstrated disabling the watchdog interactively by depositing and running the three-word sequence (CLA / IOT 6551 / HLT) and observed HALT/expiry behavior in the live status output.

Suggested next steps:
- Add `show watchdog` to the monitor `help` listing so it appears in `help` output.
- Expand `show devices` to indicate attachment status (e.g. "Watchdog (configured, attached)") by passing the runtime pointer into `show_devices()` and checking `runtime->watchdog`.
- Add a small integration test that starts the monitor with a config that attaches the watchdog, runs a short scenario, and asserts `show watchdog` output contains expected fields.
