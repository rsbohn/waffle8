# 2025-10-28 Implement a Watchdog Timer

Objectives:
- Provide a timer facility that can force a CPU reset or halt after a wall-clock timeout.
- Expose the device via IOT so guest code can control and query it.

Summary of final design and implementation (recorded):

Peripheral description
- The watchdog is a configurable countdown timer expressed in deciseconds (tenths of a second).
- The control register is a 12-bit word with a 3-bit command in bits 11..9 and a 9-bit count in bits 8..0 (count in deciseconds).

Control register encoding (bits 11..0):
- CMD (bits 11..9):
	- 000 = disabled
	- 001 = RESET (one-shot)
	- 010 = RESET (periodic)
	- 011 = HALT (one-shot)
	- 100 = HALT (periodic)
	- other encodings reserved
- COUNT (bits 8..0): initial countdown in deciseconds (0..511). 0 means disabled / no countdown.

IOT interface (device code assigned in codebase)
- IOT microbits interpretation:
	- 01 (WRITE): write AC into the control register (start/stop per CMD)
	- 02 (READ):  read the control register into AC
	- 04 (RESTART): reload the counter from the COUNT field and resume ticking

Runtime behavior and implementation notes
- The core adds a tick-callback API that devices may register. The watchdog registers a tick handler called on each CPU step with a monotonic timestamp.
- The countdown uses monotonic wall-clock time and is checked on each step; the implementation converts COUNT (deciseconds) into nanoseconds and compares against the last armed timestamp.
- When the watchdog fires:
	- RESET semantics: the core PC is set to 0 (simulating a reset vector jump).
	- HALT semantics: the core HALT state is set via the API.
	- INTERRUPT semantics were discussed but are not implemented yet; they currently map to RESET as a safe fallback.
- One-shot vs periodic: one-shot clears/disable after firing; periodic reloads and continues ticking.

Configuration and wiring
- `pdp8.config` now contains a `device watchdog { ... }` stanza. The monitor reads these fields at startup and, if enabled, creates and attaches the watchdog device.
- Config keys recognized: `iot` (documentation only), `enabled`, `mode` (string), `periodic` (bool), `default_count` (int), `pause_on_halt` (bool).

Tests and validation
- A Python factory test `factory/test_watchdog.py` exercises READ/WRITE, one-shot HALT, and one-shot RESET against the shared `libpdp8.so` — tests pass locally.
- A C test `tests/test_config.c` verifies parsing of the `pdp8.config` watchdog stanza and was extended to run invalid-config scenarios (missing stanza and out-of-bounds values). These tests pass locally.

Open/remaining items
- Device interrupts: true device interrupt delivery (DEVICE-LEVEL IRQ) is not yet implemented. Currently interrupt-mode falls back to RESET. Follow-up: wire into the core's interrupt/priority system if desired.
- Pause semantics: `pause_on_halt` is parsed and available; current implementation uses monotonic time and relies on the tick handler to avoid advancing the counter during emulator pause in practice — but more precise paused-time accounting can be implemented if required.
- More config validation: parser currently tolerates/records many invalid values; we added tests for those scenarios. Consider stricter validation and clearer errors in future.

Developer notes
- POSIX feature macros were required in a couple of files to make `clock_gettime()`/`mkdtemp()` and friends available.
- When adding the watchdog source, the relevant build targets in the `Makefile` were updated so the monitor and shared library include the new file.

Status
- Implementation: complete and merged into the workspace.
- Tests: local factory and config tests pass.

Next steps
- If you want interrupt-mode semantics implemented instead of RESET, I can wire the watchdog into the core interrupt handling and add tests.
- If you want stricter config validation, I can implement that and update tests accordingly.

