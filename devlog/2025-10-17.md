# 2025-10-17 – Python Core Prototype & Bench Harness

## Overview
Implemented a pure Python PDP-8 core alongside a KL8E console peripheral so we can benchmark interpreter performance against the existing C backend. Added a companion benchmark driver that mirrors `tools/pdp8_bench.c`, allowing apples-to-apples throughput comparisons without leaving the Python toolchain.

## Notable Changes
- Added `factory/emulator/main.py`, recreating the 4K-word CPU, instruction decoder, and KL8E handlers in Python for rapid experimentation and profiling.
- Wired a buffered console model that respects keyboard skip semantics, teleprinter flag handling, and newline-to-carriage-return translation for terminal input.
- Introduced `factory/emulator/benchmark.py` with the NOP/JMP, auto-increment, and JMS/operate loops from the C benchmark so we can characterise interpreter MIPS.

## Validation
```shell
$ python3 -m compileall factory/emulator/main.py
$ python3 -m compileall factory/emulator/benchmark.py
```

- Locked the Python core to a 4K address space (matching the stock PDP-8 field) so hot paths can use direct 12-bit masking without per-access modulo checks. The measurement run clocked in around 1.2 MIPS, which is already ahead of a real PDP-8/E's ~0.8 MIPS, albeit still ~30× slower than the C backend.

## Benchmark Results
- Python core (`python3 -m factory.emulator.benchmark 5000000`) after the 4K mask optimisation:
  - NOP/JMP loop ≈ 0.60 Mloops/s (1.20 MIPS)
  - Auto-increment loop ≈ 0.54 Mloops/s (1.08 MIPS)
  - JMS/operate loop ≈ 0.23 Mloops/s (1.39 MIPS)
- Native core (`./pdp8_bench 5000000`):
  - NOP/JMP loop ≈ 18.32 Mloops/s (36.64 MIPS)
  - Auto-increment loop ≈ 14.25 Mloops/s (28.50 MIPS)
  - JMS/operate loop ≈ 6.25 Mloops/s (37.50 MIPS)

## Next Steps
- Run `python3 -m factory.emulator.benchmark 5000000` and compare the throughput numbers with `tools/pdp8_bench`.
- Feed the Python core a handful of S-record programs (e.g. `hello-kl8e.srec`) to ensure functional parity before optimising hotspots.
